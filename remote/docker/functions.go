package docker

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	uuid2 "github.com/docker/distribution/uuid"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/go-connections/nat"
	"github.com/gofiber/websocket/v2"
	"io"
	"log"
	"os"
	"pentest-backend/database"
	"pentest-backend/database/models"
	"strings"
	"time"
)

var writeWait = 1 * time.Second
var closeGracePeriod = 2 * time.Second
var pongWait = 5 * time.Second
var pingPeriod = (pongWait * 9) / 10
var maxMessageSize = 8192

type WebSocketRequest struct {
	Key   string `json:"type"`
	Value string `json:"value"`
}

type WebSocketResponse struct {
	Client *websocket.Conn `json:"-"`
	Key    string          `json:"type"`
	Value  string          `json:"value"`
}

func CreateContainer(ctx context.Context, user models.User, project models.Project) (error, models.Container, models.Container) {

	//Victim Container

	//Pulls image for container.
	reader, err := DockerClient.ImagePull(ctx, project.VictimImage, types.ImagePullOptions{})
	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	defer reader.Close()
	io.Copy(os.Stdout, reader)

	//Sets up ports for container
	exposedPorts, portBindings, _ := nat.ParsePortSpecs(strings.SplitN(project.VictimPorts, ",", 100))

	//Creates container
	resp, err := DockerClient.ContainerCreate(ctx, &container.Config{
		Image:        project.VictimImage,
		ExposedPorts: exposedPorts,
		Cmd:          strings.SplitN(project.VictimCommands, ",", 100),
		Tty:          true,
		AttachStdout: true,
		AttachStdin:  true,
		AttachStderr: true,
		OpenStdin:    true,
	}, &container.HostConfig{
		PortBindings: portBindings, // it supposed to be nat.PortMap
	}, &network.NetworkingConfig{}, nil, fmt.Sprintf("%s-%s-%s", "victim", user.FirstName, project.Name))

	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	uuid := uuid2.Generate()

	//Creates database entry for container
	dockerContainer := models.Container{
		UUID:       uuid.String(),
		ProjectID:  project.ID,
		UserID:     user.ID,
		DockerUUID: resp.ID,
		Type:       models.Victim,
	}

	database.Client.Table("containers").Create(&dockerContainer)

	//Attack Container

	//Pulls image for container.
	reader2, err := DockerClient.ImagePull(ctx, project.AttackImage, types.ImagePullOptions{})
	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	defer reader2.Close()
	io.Copy(os.Stdout, reader2)

	//Sets up ports for container
	exposedPorts2, portBindings2, _ := nat.ParsePortSpecs(strings.SplitN(project.AttackPorts, ",", 100))

	//Creates container
	resp2, err := DockerClient.ContainerCreate(ctx, &container.Config{
		Image:        project.AttackImage,
		ExposedPorts: exposedPorts2,
		Cmd:          strings.SplitN(project.AttackCommands, ",", 100),
		Tty:          true,
		AttachStdout: true,
		AttachStdin:  true,
		AttachStderr: true,
		OpenStdin:    true,
	}, &container.HostConfig{
		PortBindings: portBindings2, // it supposed to be nat.PortMap
	}, &network.NetworkingConfig{}, nil, fmt.Sprintf("%s-%s-%s", "attacking", user.FirstName, project.Name))

	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	uuid3 := uuid2.Generate()

	//Creates database entry for container
	dockerContainer2 := models.Container{
		UUID:       uuid3.String(),
		ProjectID:  project.ID,
		UserID:     user.ID,
		DockerUUID: resp2.ID,
		Type:       models.Attack,
	}

	database.Client.Table("containers").Create(&dockerContainer2)

	AttachContainer(dockerContainer)
	AttachContainer(dockerContainer2)

	return nil, dockerContainer, dockerContainer2
}

func StartContainer(ctx context.Context, container models.Container) error {
	return DockerClient.ContainerStart(ctx, container.DockerUUID, types.ContainerStartOptions{})
}

func KillContainer(ctx context.Context, container models.Container) error {
	return DockerClient.ContainerKill(ctx, container.DockerUUID, "SIGKILL")
}

func GetWebSocketHandler(c *websocket.Conn) {
	defer func() {
		c.Close()
		Unregister <- c
	}()

	containerUuid := c.Params("container")
	var containerObject models.Container
	database.Client.Table("containers").Where("uuid", containerUuid).First(&containerObject)

	if containerObject.ID == 0 {
		return
	}

	//// Register the client
	Clients[c] = struct{ Container models.Container }{Container: containerObject}
	Register <- c

	//// websocket.Conn bindings https://pkg.go.dev/github.com/fasthttp/websocket?tab=doc#pkg-index
	c.WriteJSON(WebSocketResponse{Key: "connection", Value: "success"})

	for {
		messageType, message, err := c.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Println("read error:", err)
			}
			return
		}

		if messageType == websocket.TextMessage {
			var request WebSocketRequest
			err := json.Unmarshal(message, &request)
			if err != nil {
				response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err)}
				Broadcast <- response
				fmt.Printf("\nError occured while connecting: %v", err)
				return
			}

			switch request.Key {
			case "command":
				{
					_, err2 := SendCommand(context.Background(), containerObject, request.Value)

					if err2 != nil {
						response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
						Broadcast <- response
					} else {
						response := WebSocketResponse{Client: c, Key: "success", Value: ""}
						Broadcast <- response
					}
				}
			case "start":
				{

					err2 := StartContainer(context.Background(), containerObject)

					if err2 != nil {
						response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
						Broadcast <- response
					}

					response := WebSocketResponse{Client: c, Key: "success", Value: ""}
					Broadcast <- response
				}

			case "kill":
				{

					err2 := KillContainer(context.Background(), containerObject)

					if err2 != nil {
						response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
						Broadcast <- response
					}

					response := WebSocketResponse{Client: c, Key: "success", Value: ""}
					Broadcast <- response

				}
			}
		}
	}

	//}(c)
}

func CreateChannel(c *websocket.Conn, container models.Container) {
	fmt.Printf("\nTest")
	reader, err := DockerClient.ContainerLogs(context.Background(), container.DockerUUID, types.ContainerLogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     true,
		Timestamps: true,
	})
	if err != nil {
		panic(err)
	}
	defer reader.Close()

	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		fmt.Printf("\n%v", scanner.Text())
		Broadcast <- WebSocketResponse{Client: c, Key: "log", Value: scanner.Text()}
	}
}

func SendCommand(ctx context.Context, container models.Container, command string) (types.IDResponse, error) {
	fmt.Println("/bin/sh -c '" + command + " > /proc/1/fd/1'")
	Attachments[container] <- "/bin/sh -c '" + command + " > /proc/1/fd/1'"
	return types.IDResponse{}, nil
}

func GetLogs(ctx context.Context, container models.Container) (io.ReadCloser, error) {
	options := types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true}
	// Replace this ID with a container that really exists
	out, err := DockerClient.ContainerLogs(ctx, container.DockerUUID, options)
	return out, err
}
