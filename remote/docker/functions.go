package docker

import (
	"context"
	"encoding/json"
	"fmt"
	uuid2 "github.com/docker/distribution/uuid"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/go-connections/nat"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/websocket/v2"
	"io"
	"log"
	"net/http"
	"os"
	"pentest-backend/database"
	"pentest-backend/database/models"
	"strings"
	"time"
)

var writeWait = 1 * time.Second
var closeGracePeriod = 2 * time.Second
var pongWait = 5 * time.Second
var pingPeriod = (pongWait * 9) / 10
var maxMessageSize = 8192

type WebSocketRequest struct {
	Key   string `json:"type"`
	Value string `json:"value"`
}

type WebSocketResponse struct {
	Client *websocket.Conn `json:"-"`
	Key    string          `json:"type"`
	Value  string          `json:"value"`
}

func DeleteContainer(ctx context.Context, user models.User, project models.Project) error {
	var containers []models.Container
	database.Client.Table("containers").Where(&models.Container{ProjectID: project.ID, UserID: user.ID}).Find(&containers)

	for _, m := range containers {
		err := DockerClient.ContainerRemove(ctx, m.DockerUUID, types.ContainerRemoveOptions{})
		if err != nil {
			return err
		}
		database.Client.Table("containers").Delete(m).Where(m.ID)
	}

	return nil
}

func CreateContainer(ctx context.Context, user models.User, project models.Project) (error, models.Container, models.Container) {

	//Pulls image for container.
	reader, err := DockerClient.ImagePull(ctx, project.VictimImage, types.ImagePullOptions{})

	if reader != nil {
		err = reader.Close()
		if err != nil {

		}
		io.Copy(os.Stdout, reader)
	}

	//Sets up ports for container
	exposedPorts, portBindings, _ := nat.ParsePortSpecs(strings.SplitN(project.VictimPorts, ",", 100))

	//Creates container
	resp, err := DockerClient.ContainerCreate(ctx, &container.Config{
		Image:        project.VictimImage,
		ExposedPorts: exposedPorts,
		Cmd:          strings.SplitN(project.VictimCommands, ",", 100),
		Tty:          true,
		AttachStdout: true,
		AttachStdin:  true,
		AttachStderr: true,
		OpenStdin:    true,
		Env:          []string{"TERM=xterm-old"},
	}, &container.HostConfig{
		PortBindings: portBindings, // it supposed to be nat.PortMap
	}, &network.NetworkingConfig{}, nil, strings.Replace(fmt.Sprintf("%s-%s-%s", "victim", user.FirstName, project.Name), " ", "_", -1))

	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	uuid := uuid2.Generate()

	//Creates database entry for container
	dockerContainer := models.Container{
		UUID:       uuid.String(),
		ProjectID:  project.ID,
		UserID:     user.ID,
		DockerUUID: resp.ID,
		Type:       models.Victim,
	}

	database.Client.Table("containers").Create(&dockerContainer)

	//Attack Container

	//Pulls image for container.
	reader2, err := DockerClient.ImagePull(ctx, project.AttackImage, types.ImagePullOptions{})

	if reader2 != nil {
		err = reader2.Close()
		if err != nil {

		}
		io.Copy(os.Stdout, reader2)
	}

	//Sets up ports for container
	exposedPorts2, portBindings2, _ := nat.ParsePortSpecs(strings.SplitN(project.AttackPorts, ",", 100))

	//Creates container
	resp2, err := DockerClient.ContainerCreate(ctx, &container.Config{
		Image:        project.AttackImage,
		ExposedPorts: exposedPorts2,
		Cmd:          strings.SplitN(project.AttackCommands, ",", 100),
		Tty:          true,
		AttachStdout: true,
		AttachStdin:  true,
		AttachStderr: true,
		OpenStdin:    true,
		Env:          []string{"TERM=xterm-old"},
	}, &container.HostConfig{
		PortBindings: portBindings2, // it supposed to be nat.PortMap
	}, &network.NetworkingConfig{}, nil, strings.Replace(fmt.Sprintf("%s-%s-%s", "attacking", user.FirstName, project.Name), " ", "_", -1))

	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	uuid3 := uuid2.Generate()

	//Creates database entry for container
	dockerContainer2 := models.Container{
		UUID:       uuid3.String(),
		ProjectID:  project.ID,
		UserID:     user.ID,
		DockerUUID: resp2.ID,
		Type:       models.Attack,
	}

	database.Client.Table("containers").Create(&dockerContainer2)

	go func() {
		AttachmentChannel <- dockerContainer
		AttachmentChannel <- dockerContainer2
	}()

	return nil, dockerContainer, dockerContainer2
}

func StartContainer(ctx context.Context, container models.Container) error {
	if _, ok := Attachments[container]; !ok {
		go func() {
			AttachContainer(container)
		}()
	}
	time.Sleep(400 * time.Millisecond)
	err := DockerClient.ContainerStart(ctx, container.DockerUUID, types.ContainerStartOptions{})
	return err
}

func KillContainer(ctx context.Context, container models.Container) error {
	delete(Attachments, container)
	return DockerClient.ContainerKill(ctx, container.DockerUUID, "SIGKILL")
}

func FetchAllocation(ctx context.Context, container models.Container) (port string, host string, err error) {
	inspect, err := DockerClient.ContainerInspect(ctx, container.DockerUUID)

	if err != nil {
		return "", "", err
	}

	for host, _ := range inspect.NetworkSettings.Ports {
		return host.Port(), inspect.NetworkSettings.Networks["bridge"].IPAddress, nil
	}

	return "", "", fiber.NewError(http.StatusNotAcceptable, "This container does not have a private ip-address")
}

func FetchState(ctx context.Context, container models.Container) (online bool, err error) {
	inspect, err := DockerClient.ContainerInspect(ctx, container.DockerUUID)

	if err != nil {
		return false, err
	}

	return inspect.State.Running, nil
}

func GetWebSocketHandler(c *websocket.Conn) {
	defer func() {
		c.Close()
		Unregister <- c
	}()

	containerUuid := c.Params("container")
	var containerObject models.Container
	database.Client.Table("containers").Where("uuid", containerUuid).First(&containerObject)

	if containerObject.ID == 0 {
		return
	}

	//// Register the client
	Clients[c] = struct{ Container models.Container }{Container: containerObject}
	Register <- c

	//// websocket.Conn bindings https://pkg.go.dev/github.com/fasthttp/websocket?tab=doc#pkg-index
	c.WriteJSON(WebSocketResponse{Key: "connection", Value: "success"})

	for {
		messageType, message, err := c.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Println("read error:", err)
			}
			return
		}

		if messageType == websocket.TextMessage {
			var request WebSocketRequest
			err := json.Unmarshal(message, &request)
			if err != nil {
				response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err)}
				Broadcast <- response
				fmt.Printf("\nError occured while connecting: %v", err)
				return
			}

			switch request.Key {
			case "command":
				{
					_, err2 := SendCommand(context.Background(), containerObject, request.Value)
					if err2 != nil {
						response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
						Broadcast <- response
					} else {
						response := WebSocketResponse{Client: c, Key: "success", Value: ""}
						Broadcast <- response
					}
					break
				}
			case "start":
				{
					var containers []models.Container
					database.Client.Table("containers").Where(&models.Container{ProjectID: containerObject.ProjectID, UserID: containerObject.UserID}).Find(&containers)

					for _, projectContainers := range containers {
						err2 := StartContainer(context.Background(), projectContainers)

						if err2 != nil {
							response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
							Broadcast <- response
						}
					}

					response := WebSocketResponse{Client: c, Key: "success", Value: ""}
					Broadcast <- response
					break
				}

			case "kill":
				{
					var containers []models.Container
					database.Client.Table("containers").Where(&models.Container{ProjectID: containerObject.ProjectID, UserID: containerObject.UserID}).Find(&containers)

					for _, projectContainers := range containers {
						err2 := KillContainer(context.Background(), projectContainers)

						if err2 != nil {
							response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
							Broadcast <- response
						}
					}

					response := WebSocketResponse{Client: c, Key: "success", Value: ""}
					Broadcast <- response
					break
				}
			}
		}
	}

	//}(c)
}

func GetPower(container models.Container) (types.ContainerJSON, error) {
	inspect, err := DockerClient.ContainerInspect(context.Background(), container.DockerUUID)

	if err != nil {
		return types.ContainerJSON{}, err
	}

	return inspect, nil
}

func SendCommand(ctx context.Context, container models.Container, command string) (types.IDResponse, error) {
	if val, ok := Attachments[container]; !ok {
		go func() { AttachContainer(container) }()
		return types.IDResponse{}, fiber.NewError(http.StatusOK, "Attachment does not exist, attaching.")
	} else {
		//val <- fmt.Sprintf("/bin/sh -c ' %s > /proc/1/fd/1'", command)
		val <- command
		return types.IDResponse{}, nil
	}
}

func GetLogs(ctx context.Context, container models.Container) (io.ReadCloser, error) {
	options := types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true}
	// Replace this ID with a container that really exists
	out, err := DockerClient.ContainerLogs(ctx, container.DockerUUID, options)
	return out, err
}
