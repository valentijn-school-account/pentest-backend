package docker

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	uuid2 "github.com/docker/distribution/uuid"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/client"
	"github.com/docker/go-connections/nat"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/websocket/v2"
	"io"
	"os"
	"pentest-backend/database"
	"pentest-backend/database/models"
	"strings"
)

type WebSocketRequest struct {
	Key   string `json:"type"`
	Value string `json:"value"`
}

type WebSocketResponse struct {
	Client *websocket.Conn `json:"-"`
	Key    string          `json:"type"`
	Value  string          `json:"value"`
}

func CreateContainer(ctx context.Context, user models.User, project models.Project) (error, models.Container, models.Container) {

	//Victim Container

	//Pulls image for container.
	reader, err := DockerClient.ImagePull(ctx, project.VictimImage, types.ImagePullOptions{})
	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	defer reader.Close()
	io.Copy(os.Stdout, reader)

	//Sets up ports for container
	exposedPorts, portBindings, _ := nat.ParsePortSpecs(strings.SplitN(project.VictimPorts, ",", 100))

	//Creates container
	resp, err := DockerClient.ContainerCreate(ctx, &container.Config{
		Image:        project.VictimImage,
		ExposedPorts: exposedPorts,
		Cmd:          strings.SplitN(project.VictimCommands, ",", 100),
		Tty:          true,
	}, &container.HostConfig{
		PortBindings: portBindings, // it supposed to be nat.PortMap
	}, &network.NetworkingConfig{}, nil, fmt.Sprintf("%s-%s-%s", "victim", user.FirstName, project.Name))

	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	uuid := uuid2.Generate()

	//Creates database entry for container
	dockerContainer := models.Container{
		UUID:       uuid.String(),
		ProjectID:  project.ID,
		UserID:     user.ID,
		DockerUUID: resp.ID,
		Type:       models.Victim,
	}

	database.Client.Table("containers").Create(&dockerContainer)

	//Attack Container

	//Pulls image for container.
	reader2, err := DockerClient.ImagePull(ctx, project.AttackImage, types.ImagePullOptions{})
	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	defer reader2.Close()
	io.Copy(os.Stdout, reader2)

	//Sets up ports for container
	exposedPorts2, portBindings2, _ := nat.ParsePortSpecs(strings.SplitN(project.AttackPorts, ",", 100))

	//Creates container
	resp2, err := DockerClient.ContainerCreate(ctx, &container.Config{
		Image:        project.AttackImage,
		ExposedPorts: exposedPorts2,
		Cmd:          strings.SplitN(project.AttackCommands, ",", 100),
		Tty:          true,
	}, &container.HostConfig{
		PortBindings: portBindings2, // it supposed to be nat.PortMap
	}, &network.NetworkingConfig{}, nil, fmt.Sprintf("%s-%s-%s", "attacking", user.FirstName, project.Name))

	if err != nil {
		return err, models.Container{}, models.Container{}
	}

	uuid3 := uuid2.Generate()

	//Creates database entry for container
	dockerContainer2 := models.Container{
		UUID:       uuid3.String(),
		ProjectID:  project.ID,
		UserID:     user.ID,
		DockerUUID: resp2.ID,
		Type:       models.Attack,
	}

	database.Client.Table("containers").Create(&dockerContainer2)

	return nil, dockerContainer, dockerContainer2
}

func StartContainer(ctx context.Context, container models.Container) error {
	return DockerClient.ContainerStart(ctx, container.DockerUUID, types.ContainerStartOptions{})
}

func KillContainer(ctx context.Context, container models.Container) error {
	return DockerClient.ContainerKill(ctx, container.DockerUUID, "SIGKILL")
}

func GetWebSocketHandler() fiber.Handler {
	return websocket.New(func(c *websocket.Conn) {
		// When the function returns, unregister the client and close the connection
		defer func() {
			Unregister <- c
			c.Close()
		}()

		// Register the client
		Register <- c
		containerObject := c.Locals("container").(models.Container)
		go CreateChannel(c, containerObject)
		// websocket.Conn bindings https://pkg.go.dev/github.com/fasthttp/websocket?tab=doc#pkg-index

		for {
			var request WebSocketRequest
			if t, msg, err := c.ReadMessage(); err != nil {
				message := string(msg)
				fmt.Printf("\nMessage: %s %v", message, t)
				err := json.Unmarshal([]byte(message), &request)
				if err != nil {
					response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err)}
					Broadcast <- response
					return
				}
				break
			}

			switch request.Key {
			case "command":
				{
					_, err2 := SendCommand(context.Background(), containerObject, strings.SplitN(request.Value, " ", -1))

					if err2 != nil {
						response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
						Broadcast <- response
						break
					}

					response := WebSocketResponse{Client: c, Key: "success", Value: ""}
					Broadcast <- response
					break
				}
			case "start":
				{

					err2 := StartContainer(context.Background(), containerObject)

					if err2 != nil {
						response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
						Broadcast <- response
						break
					}

					response := WebSocketResponse{Client: c, Key: "success", Value: ""}
					Broadcast <- response
					break
				}

			case "kill":
				{

					err2 := KillContainer(context.Background(), containerObject)

					if err2 != nil {
						response := WebSocketResponse{Client: c, Key: "error", Value: fmt.Sprintf("%v", err2)}
						Broadcast <- response
						break
					}

					response := WebSocketResponse{Client: c, Key: "success", Value: ""}
					Broadcast <- response
					break
				}
			}

		}
		//}(c)
	})
}

func CreateChannel(c *websocket.Conn, container models.Container) {
	reader, err := DockerClient.ContainerLogs(context.Background(), container.DockerUUID, types.ContainerLogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     true,
		Timestamps: false,
	})
	if err != nil {
		panic(err)
	}
	defer reader.Close()

	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		Broadcast <- WebSocketResponse{Client: c, Key: "log", Value: scanner.Text()}
	}
}

func SendCommand(ctx context.Context, container models.Container, command []string) (types.IDResponse, error) {
	docker, err := client.NewEnvClient()
	if err != nil {
		return types.IDResponse{}, err
	}

	config := types.ExecConfig{
		AttachStderr: true,
		AttachStdout: true,
		Cmd:          command,
	}

	return docker.ContainerExecCreate(ctx, container.DockerUUID, config)
}

func GetLogs(ctx context.Context, container models.Container) (io.ReadCloser, error) {
	options := types.ContainerLogsOptions{ShowStdout: true}
	// Replace this ID with a container that really exists
	out, err := DockerClient.ContainerLogs(ctx, container.DockerUUID, options)
	return out, err
}
